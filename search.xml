<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统中同步互斥问题的解决方案探究]]></title>
    <url>%2F2017%2F11%2F24%2Fos0%2F</url>
    <content type="text"><![CDATA[基础知识并行：同一时刻有多个程序运行，必须有多核硬件支持 并发：同一时间段有多个程序执行，单核CPU即可实现 进程：在多道程序环境下，允许多个程序并发地执行，在单核cpu中，若顺序执行这些程序，便不能叫并发，且cpu的计算速度极快，而程序的I/O，磁盘读取等操作与CPU的速度相差好几个数量级，顺序执行会极大地降低CPU的运行效率。此时，很容易就想到，在程序做耗时操作时，CPU让给其他程序使用，而CPU的计算现场的临时变量等数据和地址需要保存。 因此引入进程的概念，进程可以理解为一个程序的一次执行，在系统运行一个程序或应用（如浏览器）时，也就为该程序创建了进程，同时为每个进程配置了一个名为进程控制块（PCB）的数据结构，用以描述进程的基本情况和运行状态，进而控制和管理进程，因此进程是系统分配资源的独立单位。它的引入，是为了更好地使多道程序并发地执行，以提高资源利用和系统吞吐量，增加并发程度。 线程线程是为了减少程序在并发执行所付出的时空开销，提升操作系统的并发性能。 线程是依赖于进程而存在的，每个线程必定有父级进程，一个进程则可以拥有多个线程，线程的生命周期自然也依赖于父进程，在进程的结束时，其下的所有线程都会随之结束。线程本身除去一些很小的运行中比不可少的资源外，不拥有系统资源，与父进程下所有线程共享该进程的全部资源，因此同进程中的线程切换仅需要很小的时空开销，类似应用向服务器请求数据此类的异步操作便可以通过线程很好地解决。 时间片轮转CPU时间片轮转在引入进程的时候就提及了，这里还需强调下，在多用户和有交互的计算机系统中，时间片轮转能极大地减少应用响应时间，提升用户体验，而在多核支持的操作系统中，使程序并行执行成为可能，但每个核上仍然是以时间片轮转的方式推进的。 同步存储现代的计算机通常都是多核，但地址总线只有一根，这就意味着，在计算机需要存储数据时，只能通过该总线同步地存储，以保证该数据无误地读写。 临界资源与临界区虽然多个进程可以共享体统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们将这种一次仅允许一个进程使用的资源称为临界资源。典型的临界资源如打印机，键盘等。他们在非特殊情况下都应该是不可被抢夺的资源。访问临界资源的代码被称为临界区。 进程的状态因操作系统中存在许多进程在同一时段内运行，为了更好地管理这些进程，操作系统会将进程按不同的特性分类，并将其放入不同的队列中，绝大多数操作系统会将进程分为以下四类： 就绪 此类进程拥有能保证当前执行的除CPU外的所有资源，也就是说，在就绪队列中的进程，只需要等待CPU的分配，如果分配到了，便能正常执行。 运行 此类进程如题，正在运行中，拥有能保证当前执行的所有资源，如发生耗时操作的时刻也会在此阶段，如运行中的程序申请打印机，那么该程序就会申请传送数据，下发打印指令，再主动将自己阻塞。而该进程CPU的时间片时间用完后，操作系统会保存现场，并给下一个就绪对列中的合适的程序分配CPU。 阻塞 故名思议，阻塞是由于该进程在进行耗时操作，通常由运行中的进程在下发完命令主动阻塞而来。如耗时操作完成，会转入就绪队列。 挂起 为止阻塞队列占用过多资源，在操作系统资源不足的情况下，会将部分阻塞进程挂起到磁盘等外存上，使其不占用内存资源。在其耗时操作完成时会进人就绪队列。 原子操作，原语在操作系统中，存在许多操作是不可被打断的，我们称这些操作为原子操作，称其使用的命令为原语。如操作系统在对进程的调度就是原子操作，是不可打断的。 P,V操作操作系统中经典的同步互斥问题及解决方案探究在操作系统中，进程并发执行的，如果不妥善处理临界资源，那么便会引发一系列的问题。比如打印机在打印到一半时被抢夺，那么打印出来的纸张就不是我们想要的了，因此，并发操作系统在设计之初便需要考虑并解决此类问题。并发操作系统的同步互斥问题也通常由临界资源和临界区引出。 简单互斥问题 两进程申请同一临界资源，需保证同一时刻下的临界资源只有一个进程访问。 此类问题是操作系统中最简单的互斥问题。现代的操作系统常使用简单的P,V等原子操作来执行。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lecture12 Memory Networks]]></title>
    <url>%2F2017%2F11%2F17%2Fml0%2F</url>
    <content type="text"><![CDATA[Abstract reason with inference components combianed with a long-term memory components long-term memory components can be read and write to using it to prediction effectively as a (dynamic) knowledge base Introduction 大多数传统的机器学习算法 没有好的方法去优雅地操作long-term memory 无法充分利用现代计算机的强大的计算能力 记忆能力差，且不精确 Memory Networks m: memory array of object I: (input feature map) converts the incoming input to the internal feature representation. G: (generalization) updates old memories given the new input. We call this generalization as there is an opportunity for the network to compress and generalize its memories at this stage for some intended future use. O: (output feature map) produces a new output (in the feature representation space), given the new input and the current memory state. R: (response) converts the output into the response format desired. 在得到输入之后，memory networks 的训练和测试流程主要分为以下几步： Convert x to an internal feature representation I(x). Update memories mi given the new input: m_i = G(m_i, I(x), m), ∀i. Compute output features o given the new input and the memory: o=O(I(x),m). Finally, decode output features o to give the final response: r = R(o). 当训练集与测试集产生差别时，m会实时存储，但I,G,O,R四个组件不会更改 I可以使用标准预处理后输入 m_H(x) = I(x) H可以对每个memory评分，在memory满了的情况下替换掉评分最低的memory]]></content>
      <tags>
        <tag>Machine Learning</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中强软弱虚的四种引用]]></title>
    <url>%2F2017%2F10%2F18%2Fjava0%2F</url>
    <content type="text"><![CDATA[Java在创建对象时形如private Object object;这样的语句创建了一个Object类型的一个引用，而object = new Object();则是在内存中创建了一个新的对象，并将该引用指向该对象。 因计算机内存有限，对象引入了生命周期的概念，在生命周期结束了的时候回收内存，释放资源，而Java并不能直接操纵对象的生命周期，由此在JDK1.2时引入了强、软、弱、虚4种引用类型。 强引用 如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 使用举例 1Object object = new Object(); 使用场景 最常见，便不作过多阐述了。 回收方法 12object = null;System.gc(); 软引用 软引用是用来描述一些有用但并不是必需的对象，如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用。 使用举例 1SoftReference&lt;Object&gt; sr = new SoftReference&lt;&gt;(new Object()); 使用场景 可以很好地解决一部分用于对象不能回收导致的OOM问题，很适合用来实现缓存。 回收方法 12sr = null;System.gc(); 弱引用 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用也可以和一个引用队列（ReferenceQueue）联合使用。 使用举例 1WeakReference&lt;Object&gt; wf = new WeakReference&lt;&gt;(new Object()); 使用场景 由于java的gc的线程优先级很低，导致调用频率并不会很高，所以仅有弱引用的对象并不会很快回收掉，使用弱引用同样可以很好地解决一部分用于对象不能回收导致的OOM问题，很适合用来实现缓存。 回收方法 1System.gc(); 虚引用 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。必须和引用队列联合使用。不能用于调用对象，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 使用举例 12ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();PhantomReference&lt;Object&gt; pr = new PhantomReference&lt;&gt;(new Object(), queue); 使用场景 由于java的gc的线程优先级很低，导致调用频率并不会很高，所以仅有弱引用的对象并不会很快回收掉，使用弱引用同样可以很好地解决一部分用于对象不能回收导致的OOM问题，很适合用来实现缓存。 回收方法 并不存在回收问题 引用队列 ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。创建引用的时候可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列，这相当于是一种通知机制。当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后，做一些我们自己想做的事情。JVM提供了一个ReferenceHandler线程，将引用加入到注册的引用队列中。 对比 引用类型 GC回收时间 用途 生存时间 强引用 never 对象的一般状态 JVM停止运行时 软引用 内存不足时 对象缓存 内存不足时终止 弱引用 GC时 对象缓存 GC后终止 虚引用 - - -]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View绘制抢占其他控件的简要解决办法]]></title>
    <url>%2F2017%2F09%2F25%2FAndroid6%2F</url>
    <content type="text"><![CDATA[需求概述现在要实现一个需求，RecyclerView的每一个item有两个信息需要展示，分别是itemName和itemSize，itemSize要求紧跟在itemName后面，itemName最多一行，超出部分使用…省略，如图。 问题概述很自然而然的想到，使用LinearLayout的layout_weight属性就解决了，像下面这样 123456789101112&lt;TextView android:id="@+id/txt_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:ellipsize="end" android:maxLines="1"/&gt; &lt;TextView android:id="@+id/txt_size" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="16sp"/&gt; 乍一看感觉还没问题，往下一滑动，是不是傻眼了hhh 如果将xml文件做少许改动，就能很好解决这一问题。 12345678910111213141516171819&lt;LinearLayout android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1"&gt; &lt;TextView android:id="@+id/txt_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:ellipsize="end" android:maxLines="1"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id="@+id/txt_size" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="16sp"/&gt; 其实也就是在第一个TextView外套了一层 因为RecyclerView的复用机制再加上ellipsize属性，这时item的根布局的width使用wrap_content会产生测量不准确的情况。它是怎么产生的呢？笔者想了很长时间没想出来，等回去翻翻书再来更，但初步确定了以下几个方向 RecyclerView 的ViewHolder的view的重绘触发机制。 weight=1及0dp的View的绘制机制。]]></content>
  </entry>
  <entry>
    <title><![CDATA[NestedScrollView嵌套RecyclerView导致的相关问题]]></title>
    <url>%2F2017%2F08%2F30%2FAndroid5%2F</url>
    <content type="text"><![CDATA[问题概述NestedScrollView和RecyclerView是support包下替代ScrollView和ListView的控件，使用NestedScrollView嵌套RecyclerView已经很好地解决了原来ScrollView嵌套ListView时的ListView的item显示不全的问题，但是直接直接嵌套不进行相关设计仍然会出现不能惯性滑动、子控件抢焦点等问题，以下是解决方案。 解决NestedScrolling嵌套RecyclerView的不能惯性滑动的问题经过阅读官方文档，发现RecyclerView已经提供了解决嵌套时的滑动问题的解决方案而这个方法是因为RecyclerView实现了NestedScrollingChild2接口而重写的方法 1234@Override public void setNestedScrollingEnabled(boolean enabled) &#123; getScrollingChildHelper().setNestedScrollingEnabled(enabled); &#125; 在ScrollingChildHelper中，setNestedScrollingEnabled()是这样工作的 123456public void setNestedScrollingEnabled(boolean enabled) &#123; if (mIsNestedScrollingEnabled) &#123; ViewCompat.stopNestedScroll(mView); &#125; mIsNestedScrollingEnabled = enabled; &#125; 也就是说，当我们给setNestedScrollingEnabled()传入false，把事件将事件拦截，应该就可以完美解决。事实也正是如此，一行代码解决问题。 1recyclerView.setNestedScrollingEnable(false); 嵌套时RecyclerView控件抢焦点。在NestedScrollView嵌套RecyclerView时，如果RecyclerView的兄弟View显示在RecyclerView上方时，加载页面时的焦点会直接在RecyclerView的第一个item上，解决办法也十分简单，直接将焦点置于该页面的根view即可解决。 在xml文件中添加以下两行代码： 12android:focusable="true"android:focusableInTouchMode="true"]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json数据解析异常而导致网络请求失败的解决办法(其一)]]></title>
    <url>%2F2017%2F08%2F20%2FAndroid4%2F</url>
    <content type="text"><![CDATA[参考文章 问题概述笔者在开发过程中临时遇到一个本来仅有web端的项目临时增加Android端，导致后端在出接口时并未考虑Android端的json数据的解析，导致接口是这样的。。。。 正确请求 12345678910111213141516&#123; "code": 0, "data": &#123; "user": &#123; "id": 145, "name": "abtion", "school_id": 1, "sex": "男", "add_on": null, "status": 1, "role": "student", "created_at": "2017-08-05 18:26:31", "updated_at": "2017-08-19 12:41:50" &#125; &#125;&#125; 错误请求 1234&#123; "code": 20002, "data": "Password Wrong"&#125; 这也就是说在请求正确时服务端返回的数据中data是在java中的一个对象，而错误时却变成了String，这就导致了错误的请求在解析json时抛出异常导致请求失败，而且抛出的异常是无法拿到错误码和错误信息的。 问题分析我们该如何解决这个问题呢，经过思考，方法有三： 呼叫可爱的后端老哥改接口，将错误信息改由message字段输出 给okhttp添加拦截器，在retrofit解析json前解析json数据并存储。 自定义Gson响应体变换器和响应变换工厂，在请求错误时抛出异常并保存错误码和错误信息。 由于该项目已经上线，再改接口无异于痴人说梦，因加拦截器的效率也不及第三种方法日后再分享，本次采用自定义Gson响应体变换器和响应变换工厂的方法来解决。 具体解决办法1、切入点首先请看一张图片 我们通常情况下跟图中一样采用的是Gosn工厂变换器，而本次抛出异常的地方就是这个变换器，自定义工厂变换器就可以完美解决我们的问题。 2、自定义Gson响应体变换器123456789101112131415161718192021222324252627class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody,T&gt; &#123; private final Gson gson; private final Type type; public GsonResponseBodyConverter(Gson gson, Type type) &#123; this.gson = gson; this.type = type; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; //将返回的json数据储存在String类型的response中 String response = value.string(); //将外层的数据解析到APIResponse类型的httpResult中 APIResponse httpResult = gson.fromJson(response,APIResponse.class); //服务端设定0为正确的请求，故在此为判断标准 if (httpResult.getCode()==0)&#123; //直接解析，正确请求不会导致json解析异常 return gson.fromJson(response,type); &#125;else &#123; //定义错误响应体，并通过抛出自定义异常传递错误码及错误信息 ErrorResponse errorResponse = gson.fromJson(response,ErrorResponse.class); throw new ResultException(errorResponse.getCode(),errorResponse.getData()); &#125; &#125;&#125; 附上APIResponse类，ErrorResponse类和ResultException类 1234567891011121314151617181920public class APIResponse&lt;T&gt; extends BaseModel &#123; private int code = -2; private T data; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 1234567891011121314151617181920212223242526public class ErrorResponse &#123; private int code; private String data; public ErrorResponse(int code, String data) &#123; this.code = code; this.data = data; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125;&#125; 12345678910111213141516171819202122232425262728public class ResultException extends IOException &#123; private int code; private String msg; public ResultException(int code, String msg) &#123; this.code = code; this.msg = msg; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 3、自定义响应变换工厂1234567891011121314151617181920212223242526272829class ResponseConverterFactory extends Converter.Factory &#123; public static ResponseConverterFactory create() &#123; return create(new Gson()); &#125; public static ResponseConverterFactory create(Gson gson) &#123; return new ResponseConverterFactory(gson); &#125; private final Gson gson; private ResponseConverterFactory(Gson gson) &#123; if (gson == null) throw new NullPointerException("gson == null"); this.gson = gson; &#125; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, java.lang.annotation.Annotation[] annotations, Retrofit retrofit) &#123; return new GsonResponseBodyConverter&lt;&gt;(gson,type); &#125; @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, java.lang.annotation.Annotation[] parameterAnnotations, java.lang.annotation.Annotation[] methodAnnotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter&lt;&gt;(gson, adapter); &#125;&#125; 4、调用自定义的响应变换工厂在构造Retrofit时在addConverterFactory()方法中传入ResponseConverterFactory.create()就可以了。 123456789101112131415/** * 构造Retrofit * * @return retrofit */ private static Retrofit getRetrofit() &#123; if (retrofit == null) &#123; retrofit = new Retrofit.Builder() .baseUrl(Config.APP_SERVER_BASE_URL) .addConverterFactory(ResponseConverterFactory.create()) .client(getClient()) .build(); &#125; return retrofit; &#125; 5、在网络请求的onFailure中接收异常信息并进行处理12345678@Override public void onFailure(Call&lt;APIResponse&lt;LoginResponse&gt;&gt; call, Throwable t) &#123; if (t instanceof ResultException) &#123; ToastUtil.showToast(((ResultException) t).getMsg(), ((ResultException) t).getCode()); &#125; else &#123; ToastUtil.showToast("网络请求失败，请稍后再试"); &#125; &#125; 到这里就完成了，别忘了Gson的请求体变换器是default限定的。改改限定符就好了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android CountDownTimer]]></title>
    <url>%2F2017%2F08%2F16%2FAndroid3%2F</url>
    <content type="text"><![CDATA[Tips在App中通常会遇到需要发送验证码的时候，因运营商短信发送延迟，用户不能即时获取验证码，为防止服务器被频繁请求，用户获取验证码错位等问题的产生，我们通常设置一个定时器来限制用户获取验证码的请求。以下使用Android中CountDownTimer来实现。 Code12345678910111213new CountDownTimer(60000, 1000) &#123; @Override public void onTick(long l) &#123; btnGetVerifyCode.setText((l / 1000) + "s"); &#125; @Override public void onFinish() &#123; btnGetVerifyCode.setClickable(true); btnGetVerifyCode.setText("获取验证码"); btnGetVerifyCode.setBackgroundColor(getResources().getColor(R.color.primary)); &#125; &#125;.start(); 当然，对象是否匿名不影响功能的实现。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中Material Design风格控件的应用（一）]]></title>
    <url>%2F2017%2F08%2F15%2FAndroid2%2F</url>
    <content type="text"><![CDATA[TextInputLayout效果以后有空再放吧 一、导入Support LibraryMaterial Design控件是Android Support Library中的一个重要的组件，要使用TextInputLayout控件，你需要导入两个Library。第一个是appcompat-v7,它确保material style可以向后兼容。第二个是Design Support Library。在你的build.gradle文件中，添加如下依赖： 12compile 'com.android.support:design:25.2.0'compile 'com.android.support:appcompat-v7:25.2.0' 二、在XML中使用该控件TextInputEditText的使用必须在TextInputLayout中才有这种MD的效果 12345678910111213&lt;android.support.design.widget.TextInputLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.design.widget.TextInputEditText android:maxLines="1" android:id="@+id/edit_mobile" android:layout_width="match_parent" android:layout_height="48dp" android:layout_marginLeft="8dp" android:hint="手机号" android:inputType="number"/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 其实这里跟EditText没有多大的区别 三、在代码中实现显示错误信息的功能1234567891011/** * 用于TextInputEditText控件显示错误信息 * @param textInputEditText 控件对象 * @param error 错误信息 */ private void showError(TextInputEditText textInputEditText, String error) &#123; textInputEditText.setError(error); textInputEditText.setFocusable(true); textInputEditText.setFocusableInTouchMode(true); textInputEditText.requestFocus(); &#125; 不解释了好吧，在检验到错误的时候调用就好了。 以上]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android入门笔记]]></title>
    <url>%2F2017%2F08%2F13%2FAndroid1%2F</url>
    <content type="text"><![CDATA[概念 android会根据不同的屏幕分辨率家在不同的文件夹，如果你想禁止Android不跟随屏幕密度加载不同文件夹的资源,只需在AndroidManifest.xml文件中添加android:anyDensity=”false”字段即可! raw目录： 用于存放各种原生资源(音频，视频，一些XML文件等)，我们可以通过openRawResource(int id)来获得资源的二进制流！ MainActivity.java主要包括以下组成部分 布局文件activity_main.xml，我们定义一个LinearLayout线性布局，在xml命名空间中定义我们所需要使用的架构，以下为代码分析 ￼ AndroidManifest.xml配置文件，以下为主要代码分析￼ 除了上述内容外： ①如果app包含其他组件的话,都要使用类型说明语法在该文件中进行声明 Server:元素 BroadcastReceiver元素 ContentProvider元素 IntentFilter元素 ②权限的声明: 在该文件中显式地声明程序需要的权限,防止app错误地使用服务, 不恰当地访问 资源,最终提高android app的健壮性 android.permission.SEND_SMS 有这句话表示app需要使用发送信息的权限,安装的时候就会提示用户, 相关权限可以在sdk参考手册查找！ 签名，Android APP都需要我们用一个证书对应用进行数字签名，为apk签名有以下好处： 应用程序升级：如果你希望用户无缝升级到新的版本，那么你必须用同一个证书进行签名。这是由于只有以同一个证书签名，系统才会允许安装升级的应用程序。如果你采用了不同的证书，那么系统会要求你的应用程序采用不同的包名称，在这种情况下相当于安装了一个全新的应用程序。如果想升级应用程序，签名证书要相同，包名称要相同！ 应用程序模块化： Android系统可以允许同一个证书签名的多个应用程序在一个进程里运行，系统实际把他们作为一个单个的应用程序，此时就可以把我们的应用程序以模块的方式进行部署，而用户可以独立的升级其中的一个模块。 代码或者数据共享： Android提供了基于签名的权限机制，那么一个应用程序就可以为另一个以相同证书签名的应用程序公开自己的功能。以同一个证书对多个应用程序进行签名，利用基于签名的权限检查，你就可以在应用程序间以安全的方式共享代码和数据了。 不同的应用程序之间，想共享数据，或者共享代码，那么要让他们运行在同一个进程中，而且要让他们用相同的证书签名。 布局Android中有六大布局,分别是: LinearLayout(线性布局)，RelativeLayout(相对布局)，TableLayout(表格布局) FrameLayout(帧布局)，AbsoluteLayout(绝对布局)，GridLayout(网格布局) 而今天我们要讲解的就是第一个布局，LinearLayout(线性布局)，我们屏幕适配的使用 用的比较多的就是LinearLayout的weight(权重属性) LinearLayout整体框架如下  当LinearLayout下有多个match_parent,它将会按特定的算式显示，算式如下 * step 1：个个都是fill_parent,但是屏幕只有一个啦,那么1 - 3 = - 2 fill__parent * step 2：依次比例是1/6,2/6,3/6 * step 3：先到先得,先分给one,计算: 1 - 2 * (1/6) = 2/3 fill_parent 接着到two,计算: 1 - 2 * (2/6) = 1/3 fill_parent 最后到three,计算 1 - 2 * (3/6) = 0 fill_parent * step 4：所以最后的结果是:one占了两份,two占了一份,three什么都木有 RelativeLayout￼ margin与padding的区别 初学者对于这两个属性可能会有一点混淆，这里区分下： 首先margin代表的是偏移,比如marginleft = “5dp”表示组件离容器左边缘偏移5dp; 而padding代表的则是填充,而填充的对象针对的是组件中的元素,比如TextView中的文字 比如为TextView设置paddingleft = “5dp”,则是在组件里的元素的左边填充5dp的空间！ margin针对的是容器中的组件，而padding针对的是组件中的元素，要区分开来！ TableLayout …… 控件 TextView 包含id,layout_width,layout_height,gravity,text,textColor,textStyle,textSize,background 9个基本属性。 带阴影的TextView 带边框的TextView 矩形边框的Drawable 圆角矩形边框的Drawable 带图片的TextView 使用autoLink属性识别链接类型 TextView中插入HTML SpannableString&amp;SpannableStringBuilder定制文本 实现跑马灯效果的TextView 设置TextView字间距和行间距 自动换行 EditText 设置默认提示文本 获得焦点后全选组件内所有文本内容 限制EditText输入类型 设置最小行，最多行，单行，多行，自动换行 设置文字间隔，设置英文字母大写类型 控制EditText四周的间隔距离与内部文字与边框间的距离 设置EditText获得焦点，同时弹出小键盘 EditText光标位置的控制 带表情的EditText的简单实现 带删除按钮的EditText Button and ImageButton StateListDrawable drawable:引用的Drawable位图,我们可以把他放到最前面,就表示组件的正常状态~ state_focused:是否获得焦点 state_window_focused:是否获得窗口焦点 state_enabled:控件是否可用 state_checkable:控件可否被勾选,eg:checkbox state_checked:控件是否被勾选 state_selected:控件是否被选择,针对有滚轮的情况 state_pressed:控件是否被按下 state_active:控件是否处于活动状态,eg:slidingTab state_single:控件包含多个子控件时,确定是否只显示一个子控件 state_first:控件包含多个子控件时,确定第一个子控件是否处于显示状态 state_middle:控件包含多个子控件时,确定中间一个子控件是否处于显示状态 state_last:控件包含多个子控件时,确定最后一个子控件是否处于显示状态 实现按钮的按下效果 使用颜色值绘制圆角按钮 实现Material Design水波效果的Button ImageView ImageView的src属性和blackground的区别； 解决blackground拉伸导致图片变形 设置透明度 Java代码中设置blackground和src属性 adjustViewBounds设置图像缩放时是否按长宽比 scaleType设置缩放类型 fitXY:对图像的横向与纵向进行独立缩放,使得该图片完全适应ImageView,但是图片的横纵比可能会发生改变 fitStart:保持纵横比缩放图片,知道较长的边与Image的编程相等,缩放完成后将图片放在ImageView的左上角 fitCenter:同上,缩放后放于中间; fitEnd:同上,缩放后放于右下角; center:保持原图的大小，显示在ImageView的中心。当原图的size大于ImageView的size，超过部分裁剪处理。 centerCrop:保持横纵比缩放图片,知道完全覆盖ImageView,可能会出现图片的显示不完全 centerInside:保持横纵比缩放图片,直到ImageView能够完全地显示图片 matrix:默认值，不改变原图的大小，从ImageView的左上角开始绘制原图， 原图超过ImageView的部分作裁剪处理 最简单的绘制圆形的ImageView RadioButton(单选按钮)&amp;Checkbox(复选框) 基本用法与事件处理 RadioButton(单选按钮) CheckBox(复选框) 自定义点击效果 改变文字与选择框的相对距离 修改文字与选择框的距离 开关按钮ToggleButton和开关Switch ToggleButton android:disabledAlpha：设置按钮在禁用时的透明度 android:textOff：按钮没有被选中时显示的文字 android:textOn：按钮被选中时显示的文字 另外，除了这个我们还可以自己写个selector，然后设置下Background属性即可~ Switch android:showText：设置on/off的时候是否显示文字,boolean android:splitTrack：是否设置一个间隙，让滑块与底部图片分隔,boolean android:switchMinWidth：设置开关的最小宽度 android:switchPadding：设置滑块内文字的间隔 android:switchTextAppearance：设置开关的文字外观，暂时没发现有什么用… android:textOff：按钮没有被选中时显示的文字 android:textOn：按钮被选中时显示的文字 android:textStyle：文字风格，粗体，斜体写划线那些 android:track：底部的图片 android:thumb：滑块的图片 android:typeface：设置字体，默认支持这三种:sans, serif, monospace;除此以外还可以使用 其他字体文件(*.ttf)，首先要将字体文件保存在assets/fonts/目录下，不过需要在Java代码中设置： Typeface typeFace =Typeface.createFromAsset(getAssets(),”fonts/HandmadeTypewriter.ttf”); textView.setTypeface(typeFace); ProgressBar(进度条) 圆形进度条 水平进度条 使用动画替代圆形进度条 自定义圆形进度条 SeekBar(拖动条) 基本用法，它是ProgressBar的子类，所以进度条的属性拖动条皆可使用。 简单SeekBar定制 RatingBar(星级评分条) 基本用法，同样为ProgressBar的子类，你懂的 相关属性 android:isIndicator：是否用作指示，用户无法更改，默认false android:numStars：显示多少个星星，必须为整数 android:rating：默认评分值，必须为浮点数 android:stepSize： 评分每次增加的值，必须为浮点数 除了上面这些，还有两种样式供我们选择咧，但是不建议使用，因为这两种样式都好丑… 他们分别是： style=”?android:attr/ratingBarStyleSmall” style=”?android:attr/ratingBarStyleIndicator” 事件处理 只需为RatingBar设置OnRatingBarChangeListener事件，然后重写下onRatingChanged()方法即可！ 定制 ScrollView(滚动条) 滚动到底部 设置滚动到滑块图片 隐藏滑块 设置滚动速度 Date&amp;Time组件 TextClock AnalogClock(模拟时钟) Chronometer(计时器) DatePicker(日期选择器) android:calendarTextColor ： 日历列表的文本的颜色 android:calendarViewShown：是否显示日历视图 android:datePickerMode：组件外观，可选值:spinner，calendar 前者效果如下，默认效果是后者 android:dayOfWeekBackground：顶部星期几的背景颜色 android:dayOfWeekTextAppearance：顶部星期几的文字颜色 android:endYear：去年(内容)比如2010 android:firstDayOfWeek：设置日历列表以星期几开头 android:headerBackground：整个头部的背景颜色 android:headerDayOfMonthTextAppearance：头部日期字体的颜色 android:headerMonthTextAppearance：头部月份的字体颜色 android:headerYearTextAppearance：头部年的字体颜色 android:maxDate：最大日期显示在这个日历视图mm / dd / yyyy格式 android:minDate：最小日期显示在这个日历视图mm / dd / yyyy格式 android:spinnersShown：是否显示spinner android:startYear：设置第一年(内容)，比如1994年 android:yearListItemTextAppearance：列表的文本出现在列表中。 android:yearListSelectorColor：年列表选择的颜色 TimePicker CalendarView(日期视图) android:firstDayOfWeek：设置一个星期的第一天 android:maxDate ：最大的日期显示在这个日历视图mm / dd / yyyy格式 android:minDate：最小的日期显示在这个日历视图mm / dd / yyyy格式 android:weekDayTextAppearance：工作日的文本出现在日历标题缩写 ListView 自定义BaseAdapter，然后绑定ListView 表头表位分割线的设置 列表从底部开始显示 设置点击颜色cacheColorHint 隐藏滑动条 此为初学Android时记的笔记，因效率较低故停下。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用接口实现Fragment与Activity间的通信]]></title>
    <url>%2F2017%2F08%2F13%2FAndroid0%2F</url>
    <content type="text"><![CDATA[问题概述Fragment以优越的性能被广泛使用于Android应用中，但其并不能与Activity直接通信，对此，网上提出了众多解决方案，参考许多方案后，我决定在项目中采用接口实现两者间的通信，便于维护且相对简单。 代码示例代码背景 一个应用需实现忘记密码功能，在此功能中，我们创建了一个Activity用于承载忘记密码模块的所有功能实现，忘记密码模块所有页面逻辑都依赖于Fragment来实现，第一个页面就是获取手机号并请求后台为该手机号发送验证码 代码详解1. 在Fragment中创建Interface12345678/** * Fragment与Activity通信的接口 * 用于传递输入的电话号码 */ public interface InputMobileListener &#123; //传入电话号码给Activity void inputPhoneNumberNextAction(String mobile); &#125; 这里在Fragment中定义了一个接口，在接口中写了一个方法以保存手机号的字符串为参数， 2. 在Fragment所依赖的Activity中实现接口并重写方法12345678910public class ForgetPwdActivity implements InputMobileFragment.InputMobileListener&#123; ······ @Override public void inputPhoneNumberNextAction(final String mobile) &#123; //替换Fragment replaceFragment(R.id.frame_layout, checkCodeFragment, null); //请求后台为该号码发送验证码 sendVerifyCode(mobile); &#125;&#125; 在Activity中重写该方法，在方法体中接收到手机号并进行一系列操作，此处是发送验证码 3. 在Fragment中重写回调方法Fragment与Activity一样，在创建和销毁时都会回调一系列回调方法，而onAttach方法是在Fragment创建之初回调的，所以我们重写onAttach方法便可以保证Fragment全程皆能调用接口中的方法。 1234567891011@Overridepublic void onAttach(Activity activity) &#123; super.onAttach(activity); //抓取异常，在父Activity未实现接口时抛出。 try &#123; //Java的多态特性之一，父类引用子类对象 InputMobileListener inputMobileListener = (InputMobileListener) activity; &#125; catch (ClassCastException e) &#123; throw new ClassCastException(activity.toString() + getString(R.string.implementSPN)); &#125;&#125; 4. 在Fragment中通过接口引用Activity对象调用接口方法1234567public void onButtonClicked()&#123; //获取手机号输入框中的手机号 String mobile = mobileEdit.getText().toString().trim(); //此处应对获取的手机号做正则匹配，无关代码便不列出了 //调用重写后的接口方法 inputMobileListener = (InputMobileListener) activity;&#125; 到这就是全部实现了，这其实就是Java多态的一种应用，相信你很快就能掌握。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
